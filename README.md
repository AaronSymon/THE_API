Outdated, new version of readme.md coming soon

# THE_API
An experimental project to simplify the creation of RESTful APIs by using Node.js, Express.js, Typescript, TypeORM and Mysql.

**Note:**
1. RESTFul API generated by this project need to have an account, you may add column into `src/entity/user.entity.ts` document,
but it is not recommanded to delete it
2. This project is still in development, so it is not recommanded to use it in production.

## How to use it

1. Clone the repository
2. Run `npm install` to install all the dependencies
3. by using a [.env](#env-file) file, configure the database connection, application, server port, etc.
4. Run `npx tsc` to compile the typescript files into javascript files for the first time
5. Create the database according to the configuration in the [.env](#env-file) file
6. Create your [entities](#entity-file) in the `src/entity` folder
7. Run `npm run migration:generate` to generate a migration files and run `npm run migration:run` to create the tables in the database
8. run `npm run generate:caches` to generate the [cache files](#cache-file)
9. run `npm run generate:access` to generate the [access files](#access-file)
10. run `npm run generate:dtos` to generate the [dto files](#dto-file)
11. run `npm run generate:personalizedControllers` to generate the [personalizedControllers files](#personalizedControllers-file)
12. run `npm run generate:routers` to generate the [router files](#router-file)
13. run `npm run generate:swagger` to generate the [swagger documentation](#documentation)
14. run `npm run genetate:swaggerImplements` to generate the [swagger documentation](#documentation) implements
15. run `npm run start:swagger` to generate the swagger-ui and start the server

### .env file
In the code below, a `.env` file example. Place it to the root of the project. Use it to configure the database connection.
```
#App data
APP_NAME: 'Name of your project'
APP_VERSION: 'Version of your project'
APP_DESCRIPTION: 'Description of your project'

#Server Config
SV_PORT: 3000
SV_HOSTNAME: 'localhost'

#DataBaseConfig
DB_HOST:'localhost'
DB_PORT: 3306
DB_USER: 'root'
DB_PASSWORD: 'your_password'
DB_DATABASE: 'name_of_your_database'
DB_CHARSET: 'utf8mb4'
DB_POOL_SIZE: 10
DB_PREFIX: 'prefix_of_your_tables'

#Logs
LOG_LIMIT_SIZE: 1000000 #1Mo #Limit size of log file
LOG_LIMIT_FILES: 10 #Limit number of log files

#Cache
#Timer to define how long data will be stored in cache
CA_TIMER: 30000 #Milliseconds #30Secondes

#Tokens secret keys
TK_SECRETKEY: 'your_secret_key_for_token'
TK_SECRETREFRESHKEY: 'your_secret_key_for_refresh_token'

#Timer to define how long tokens will be valid
# '20s' = 20 seconds, '1m' = 1 minute, '2h' = 2 hours, '1d' = 1 day
TK_VALIDTOKENTIMER: '20m' #Timer to define how long tokens will be valid
TK_VALIDREFRESHTOKENTIMER: '3d' #Timer to define how long refresh tokens will be valid

TL_TIMER: 7200000

```

### Entity file

**One file = One table in the dataBase** <br>

An entity file, is a file used by TypeORM to create a table in the database, but also to create all file required 
to configure and manage the API. <br>
Each entity file must be placed in the `src/entity` folder and must be named with the following pattern: `entity_name.entity.ts` <br>

In the code below, an entity `category.entity.ts`example. Place it to the `src/entity` folder.
All entity have to be based on typeORM recommendations. [See typeORM documentation](https://typeorm.io/#/entities)

```
import {Column, Entity, ManyToMany} from "typeorm";
import {Base} from "./base/base";
import {Question} from "./question.entity";

@Entity()
export class Category extends Base{

    @Column({nullable: false, type: "varchar"})
    name: string

    @ManyToMany(() => Question, (question) => question.categories)
    questions: Question[]

}
```

### Cache file

A cache file, is a file generated by the command `npm run generate:caches` and placed in the `src/cache` folder. <br>
Each cache file is named with the following pattern: `entity_name.cache.ts` <br>
You can define if you want to cache an entity or not by setting the value of `isEntityCached` to `true` or `false` <br>

In the code below, a cache file `category.cache.ts` example.
```
//Import category
import {Category} from '../entity/category.entity';

//categoryCache document, par défault Category n'est pas mis en cache
//categoryCache document, by default Category is not cached
export const categoryCache : entityCache = {

    entity : Category,
    //Mettre la valeur de isEntityCached à true pour mettre en cache l'entité Category
    //Set the value of isEntityCached to true to cache the Category entity
    isEntityCached : false
}
```

### Access File

An access file, is a file generated by the command `npm run generate:access` and placed in the `src/access` folder. <br>
Each access file is named with the following pattern: `entity_name.access.ts` <br>

By default, in `src/access/userRoles/userRoles.ts`, 3 kind of user roles are defined: `User`, `Admin` and `SuperAdmin`. You can add or remove user roles in this file.

In the code below, an access file `category.access.ts` example.
```
//categoryAccess document, pour chacun des types d'utilisateur, supprimer les méthodes d'accès HTTP non autorisées ainsi que les params des méthodes GET non autorisés
//categoryAccess document, for each user type, delete unauthorized HTTP access methods and unauthorized GET method params
export const categoryAccess : Set<entityAccess> = new Set([
    {
        userRole: "User",
        accessMethods: new Set(["GET", "POST", "PUT", "DELETE"]),
        //AccessParams accepted in URL for GET method only (ex: /category/:name, /category/:questions , /category/:name/:questions)
        //If request method is GET but request params are not included in the array, the access will be denied
        getAccessParams: ["id", "name","questions"]
    },
    {
        userRole: "Admin",
        accessMethods: new Set(["GET", "POST", "PUT", "DELETE"]),
        //AccessParams accepted in URL for GET method only (ex: /category/:name, /category/:questions , /category/:name/:questions)
        //If request method is GET but request params are not included in the array, the access will be denied
        getAccessParams: ["id", "name","questions"]
    },
    {
        userRole: "SuperAdmin",
        accessMethods: new Set(["GET", "POST", "PUT", "DELETE"]),
        //AccessParams accepted in URL for GET method only (ex: /category/:name, /category/:questions , /category/:name/:questions)
        //If request method is GET but request params are not included in the array, the access will be denied
        getAccessParams: ["id", "name","questions"]
    },
])
```
As you can see, the `categoryAccess` file is a `Set` of `entityAccess` objects. <br>
Each `entityAccess` object is defined by 3 properties: <br>
- `userRole` : the user role for which the access is defined
- `accessMethods` : the HTTP methods allowed for the user role
- `getAccessParams` : the params allowed for the GET method for the user role

You can manage the access for each user role by adding or removing an `accessMethod` or a `getAccessParams` .

### Dto File

A dto file, is a file generated by the command `npm run generate:dto` and placed in the `src/dto` folder. <br>
Each dto file is named with the following pattern: `entity_name.dto.ts` <br>

In the code below, a dto file `category.dto.ts` example.
```
import {Category} from '../entity/category.entity';
import {QuestionDto} from './question.dto';

export class CategoryDto {

    readonly id: number;
    readonly name: string;
    readonly questions:  QuestionDto[];

    constructor(category: Category) {

        this.id = category.id;
        this.name = category.name;
        category.questions ? this.questions = category.questions.map(question => new QuestionDto(question)) : this.questions = undefined
    }

}
```
As you can see, a dto file is a class that contains all the properties of the entity. <br>
In the constructor, you can define the properties of the dto file by deleting the properties you don't want to include into it <br>

### PersonalizedControllers File

This file is optional and can be used to add personalized methods to the controllers. <br>
A personalizedControllers file, is a file generated by the command `npm run generate:personalizedControllers` and placed in the `src/router/personalizedController` folder. <br>

By default, a generated router file contains 5 methods: `getAll`, `getOne`, `createOne`, `updateOne` and `deleteOne`. <br>
Those methods working by the id of an instance of the entity. <br>
If you want to add a personalized GET method, you can do it in the `personalizedControllers` file. <br>

In the code below, a personalizedControllers file `category.personalizedControllers.ts` example.
```
import {Category} from "../../entity/category.entity";
import {AppDataSource} from "../../data-source.config";

export function findByName(name: string){

    const entityRepository = AppDataSource.getRepository(Category);

    return entityRepository.find({
        where : {
            name: name
        }
    })
}

```
As you can see, a personalizedControllers file is a file that contains function <br>
In the code above, the function `findByName` is a personalized GET method that return all the instances of the entity `Category` that have the name `name` <br>
When generating the router file, the personalized GET method will be added to the router file. <br>
For example, this controller can be called by the following URL: `http://localhost:3000/category/findByName/:name` <br>


### Router File

A router file, is a file generated by the command `npm run generate:routers` and placed in the `src/router` folder. <br>
Each router file is named with the following pattern: `entity_name.router.ts` <br>

By default, a generated router file contains 5 methods: `getAll`, `getOne`, `createOne`, `updateOne` and `deleteOne` but can be generated with personalized GET methods. <br>

In the code below, a router file `category.router.ts` example.
```
//Import Express
const express = require('express');
import { Request, Response } from 'express';

//Import de l'entité Category
import {Category} from "../entity/category.entity";

//Import du dto de l'entité Category
import { CategoryDto } from '../dto/category.dto';

//Import des access de Category
import {categoryAccess} from "../access/category.access";

//Import httpMethodsToDataBase
import getOne from "../tools/httpMethodToDataBase/getOne";
import getAll from "../tools/httpMethodToDataBase/getAll";
import insert from "../tools/httpMethodToDataBase/insert";
import update from "../tools/httpMethodToDataBase/update";
import deleteOne from "../tools/httpMethodToDataBase/deleteOne";

//Import des middlewares
import verifyToken from "../tools/jwt/verifyToken";
import {verifyUserAccessMiddleware} from "../tools/access/verifyUserAccessByRole";

//Import des controllers spécifiques
import {findByName } from "./personalizedController/category.personalizedController";
//Import de la fonction permettant de renvoyer le dto d'un controller spécifique
import sendDtoResultFromPersonalizedController from "../tools/router/personalizedController/sendDtoResultFromPersonalizedController";



//Import cache
import * as cache from 'memory-cache';
import {categoryCache} from "../cache/category.cache";
import createCache from "../tools/caches/createCache";
import deleteCache from "../tools/caches/deleteCache";
import searchCache from "../tools/caches/searchCache";

//Déclaration du router Category
export const categoryRouter = express.Router();

//Méthode GET pour récupérer toutes les instances de Category
categoryRouter.get('/', verifyToken, verifyUserAccessMiddleware(categoryAccess), async (req: Request, res: Response) => {

//Exécuter le code contenu dans le bloc try pour récupérer toutes les instances de Category
    try {

        //Vérifier si Category est à mettre en cache
        switch (categoryCache.isEntityCached) {

            //Si Category est à mettre en cache
            case true:

                //Vérifier si Category est déjà en cache
                let isCachedExisting : boolean = searchCache(req)

                //Si Category est déjà en cache   
                if(isCachedExisting) {

                    //Récupérer Category en cache
                    return res.status(200).json(cache.get(req.url))

                }

                //Si Category n'est pas en cache, le mettre en cache
                // @ts-ignore
                return createCache(req, res, await getAll <Category, CategoryDto>(Category, CategoryDto))

            //Si Category n'est pas à mettre en cache
            case false:

                //Récupérer toutes les instances de Category
                // @ts-ignore
                return res.status(200).json(await getAll <Category, CategoryDto>(Category, CategoryDto));

        }

        //Si une erreur est survenue, renvoyer une réponse avec le code 500
    } catch (e) {

        //console.log(e);

        return res.status(500).json({message: 'message: An error occurred while trying to get all Category'});


    }

});

//Méthode GET pour récupérer une instance de Category par son id
categoryRouter.get('/:id(\\d+)', verifyToken, verifyUserAccessMiddleware(categoryAccess), async (req: Request, res: Response) => {

    //Exécuter le code contenu dans le bloc try pour récupérer une instance de Category par son id
    try {

        //Vérifier si Category est à mettre en cache
        switch (categoryCache.isEntityCached) {

            //Si Category est à mettre en cache
            case true:

                //Vérifier si Category est déjà en cache
                let isCachedExisting : boolean = searchCache(req)

                //Si Category est déjà en cache
                if(isCachedExisting) {

                    //Récupérer Category en cache
                    return res.status(200).json(cache.get(req.url))

                }

                //Si Category n'est pas en cache, le mettre en cache
                // @ts-ignore
                return createCache(req,res, await getOne<Category, CategoryDto>(Category, Number(req.params.id), CategoryDto))

            //Si Category n'est pas à mettre en cache
            case false:

                //Récupérer une instance de Category par son id
                // @ts-ignore
                return res.status(200).json(await getOne<Category, CategoryDto>(Category, Number(req.params.id), CategoryDto))

        }

        //Si une erreur est survenue, renvoyer une réponse avec le code 500
    } catch (e) {

        //console.log(e);
        return res.status(500).json({message: `An error occurred while trying to get Category with ID ${req.params.id}`});

    }

});


//Méthode GET pour récupérer une ou des instance(s) de Category par : name
categoryRouter.get('/findByName/:name([a-zA-Z0-9@#?!%20%3F.]+)', verifyToken, verifyUserAccessMiddleware(categoryAccess), async (req: Request, res: Response) => {

    //Exécuter le code contenu dans le bloc try pour récupérer une ou des instance(s) de category par : name
    try {

        //Vérifier si Category est à mettre en cache
        switch (categoryCache.isEntityCached) {

            //Si Category est à mettre en cache
            case true:

                //Vérifier si Category est déjà en cache
                let isCachedExisting : boolean = searchCache(req)

                //Si Category est déjà en cache
                if(isCachedExisting) {

                    //Récupérer Category en cache
                    return res.status(200).json(cache.get(req.url))

                }

                //Si Category n'est pas en cache, le mettre en cache
                return createCache(req, res, await sendDtoResultFromPersonalizedController(await findByName(req.params.name) , Category))

            //Si Category n'est pas à mettre en cache
            case false:

                //Récupérer une ou des instance(s) de Category par : name
                return res.status(200).json(await sendDtoResultFromPersonalizedController(await findByName(req.params.name) , Category) )

        }

    } catch (e) {

        //console.log(e);
        return res.status(500).json({message: `Une erreur est survenue, imposible de récupérer une ou des instance(s) de category par : name`});

    }

});



//Méthode POST pour insérer une instance de Category
categoryRouter.post('/', verifyToken, verifyUserAccessMiddleware(categoryAccess), async (req: Request, res: Response) => {

    //Exécuter le code contenu dans le bloc try pour créer une instance de Category
    try {

        //Créer une instance de Category
        let categoryToInsert: Category = new Category()

        //Affecter les valeurs des propriétés de Category avec les valeurs contenues dans le corps de la requête
        categoryToInsert.name = req.body.name
        categoryToInsert.questions = req.body.questions

        //Vérifier si Category est à mettre en cache
        switch (categoryCache.isEntityCached) {

            //Si Category est à mettre en cache
            case true:

                //Vérifier si Category est déjà en cache
                let isCachedExisting : boolean = searchCache(req)

                //Si Category est déjà en cache
                if (isCachedExisting) {

                    //Supprimer Category du cache et insérer Category dans la base de données
                    await deleteCache(req, res, await insert(Category, categoryToInsert))

                    return res.status(201).json({message: 'Instance of Category created successfully.'})

                }

                //Si Category n'est pas en cache, insérer Category dans la base de données
                await insert(Category, categoryToInsert)

                return res.status(201).json({message: 'Instance of Category created successfully.'})

            //Si Category n'est pas à mettre en cache    
            case false:
                //Insérer category dans la base de données
                await insert(Category, categoryToInsert)

                return res.status(201).json({message: 'Instance of Category created successfully.'})

        }

        //Si une erreur est survenue, renvoyer une réponse avec le code 500    
    } catch (e) {

        //console.log(e);
        return res.status(500).json({message: 'an error occurred while inserting Category}'});

    }

});

//Méthode PUT pour mettre à jour une instance de Category par son id
categoryRouter.put('/:id(\\d+)', verifyToken, verifyUserAccessMiddleware(categoryAccess), async (req: Request, res: Response) => {

//Exécuter le code contenu dans le bloc try pour mettre à jour une instance de Category par son id 
    try {

        //Créer une instance de Category
        let categoryToUpdate: Category = new Category()

        //Déclarer une variable pour stocker l'instance de Category mise à jour
        let updated;

        //Affecter les valeurs des propriétés de categoryToUpdate avec les valeurs contenues dans le corps de la requête
        categoryToUpdate.name = req.body.name
        categoryToUpdate.questions = req.body.questions

        //Vérifier si Category est à mettre en cache
        switch (categoryCache.isEntityCached) {

            //Si Category est à mettre en cache
            case true:

                //Vérifier si Category est déjà en cache
                let isCachedExisting : boolean = searchCache(req)

                //Si Category est déjà en cache
                if(isCachedExisting) {

                    //Supprimer Category du cache et mettre à jour Category dans la base de données
                    //@ts-ignore
                    return await deleteCache(req, res, await update<Category, CategoryDto>(Category, Number(req.params.id), categoryToUpdate, CategoryDto))

                }

                //Si Category n'est en cache, mettre à jour Category dans la base de données
                //@ts-ignore
                updated = await update<Category, CategoryDto>(Category, Number(req.params.id), categoryToUpdate, CategoryDto)

                //Envoyer une réponse avec le code 200 et l'instance de Category mise à jour
                return res.status(200).json(updated)

            //Si Category n'est pas à mettre en cache    
            case false:

                //Mettre à jour Category dans la base de données
                //@ts-ignore
                updated = await update<Category, CategoryDto>(Category, Number(req.params.id), categoryToUpdate, CategoryDto)

                //Envoyer une réponse avec le code 200 et l'instance de Category mise à jour
                return res.status(200).json(updated)

        }
        //Si une erreur est survenue, renvoyer une réponse avec le code 500
    } catch (e) {

        //console.log(e);
        return res.status(500).json({message: `An error occurred while trying to update Category with ID ${req.params.id}`});

    }

});

//Méthode DELETE pour supprimer une instance de Category par son id
categoryRouter.delete('/:id(\\d+)', verifyToken, verifyUserAccessMiddleware(categoryAccess), async (req: Request, res: Response) => {

//Exécuter le code contenu dans le bloc try pour supprimer une instance de Category par son id
    try {

        //Déclarer une variable pour stocker l'instance de Category supprimée
        let deleted;

        //Vérifier si Category est à mettre en cache
        switch (categoryCache.isEntityCached) {

            //Si Category est à mettre en cache
            case true:

                //Vérifier si Category est déjà en cache
                const isCachedExisting : boolean = searchCache(req)

                //Si Category est déjà en cache
                if(isCachedExisting) {

                    //Supprimer Category du cache et supprimer Category de la base de données
                    //@ts-ignore
                    return await deleteCache(req, res, await deleteOne<Category>(Category, Number(req.params.id)))

                }

                //Si Category n'est pas en cache, supprimer Category de la base de données
                //@ts-ignore
                deleted = await deleteOne<Category>(Category, Number(req.params.id))

                //Envoyer une réponse avec le code 200 et l'instance de category supprimée
                return res.status(200).json(deleted);

            //Si Category n'est pas à mettre en cache    
            case false:

                //Supprimer category de la base de données
                //@ts-ignore
                deleted = await deleteOne<Category>(Category, Number(req.params.id));

                //Envoyer une réponse avec le code 200 et l'instance de category supprimée
                return res.status(200).json(deleted);

        }

        //Si une erreur est survenue, renvoyer une réponse avec le code 500
    } catch (e) {

        //console.log(e);
        return res.status(500).json({message: `An error occurred while trying to delete Category with ID ${req.params.id}`});

    }

});
    
```

### Documentation